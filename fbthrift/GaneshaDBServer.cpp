/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "gen-cpp2/Benchmark.h"
#include <iostream>
#include <algorithm>
#include <vector>
#include <memory>
#include <stdexcept>
#include <sstream>
#include <chrono>
#include <folly/init/Init.h>
#include <thrift/lib/cpp2/server/ThriftServer.h>

using namespace std;
using namespace apache::thrift;
using namespace  ::example;
using namespace  ::example::cpp2;

using std::shared_ptr;
using std::unique_ptr;
using std::string;

class BenchmarkHandler : virtual public BenchmarkSvIf {
private:
	void copy_benchmark_data(BenchmarkData &dest, const unique_ptr<BenchmarkData> &src) {
		dest.request_id = src->request_id;
		dest.client_latency = src->client_latency;
		dest.db_latency = src->db_latency;
		dest.dict_latency = src->dict_latency;
		dest.leaf_latency = src->leaf_latency;
		dest.io_latency = src->io_latency;
		dest.bypass_dict = src->bypass_dict;
		dest.bypass_cpu = src->bypass_cpu;
		dest.bypass_leaf = src->bypass_leaf;
		dest.bypass_io = src->bypass_io;

		// dest.data = src->data;
		dest.data_size = src->data_size;
		dest.empty_data_on_resp = src->empty_data_on_resp;
	}
public:
	BenchmarkHandler() {
		// Your initialization goes here
	}

#if 1
	void async_tm_key_put(unique_ptr<HandlerCallback<unique_ptr<BenchmarkData>>> callback, unique_ptr<string> key, unique_ptr<BenchmarkData> bench) {
		auto s = std::chrono::high_resolution_clock::now();

		BenchmarkData _ret;
		copy_benchmark_data(_ret, bench);
		if (_ret.get_empty_data_on_resp()) {
			string empty;
			_ret.set_data(empty);
			_ret.set_data_size(0);
		}

		auto e = std::chrono::high_resolution_clock::now();
		auto l = std::chrono::duration_cast<std::chrono::nanoseconds>(e-s).count();
		_ret.set_db_latency(l);
		callback->result(_ret);
	}

	void async_tm_key_get(unique_ptr<HandlerCallback<unique_ptr<BenchmarkData>>> callback, unique_ptr<string> key, unique_ptr<BenchmarkData> bench) {
		auto s = std::chrono::high_resolution_clock::now();

		BenchmarkData _ret;
		copy_benchmark_data(_ret, bench);
		assert(_ret.get_data().size() == 0 && _ret.get_data_size() != 0);

		_ret.set_data(string(_ret.get_data_size(), 'A'));

		auto e = std::chrono::high_resolution_clock::now();
		auto l = std::chrono::duration_cast<std::chrono::nanoseconds>(e-s).count();
		_ret.set_db_latency(l);
		callback->result(_ret);
	}
#else
	void key_put(BenchmarkData& _ret, unique_ptr<string> key, unique_ptr<BenchmarkData> bd) {
		auto s = std::chrono::high_resolution_clock::now();

		copy_benchmark_data(_ret, bd);
		if (_ret.get_empty_data_on_resp()) {
			string empty;
			_ret.set_data(empty);
			_ret.set_data_size(0);
		}

		auto e = std::chrono::high_resolution_clock::now();
		auto l = std::chrono::duration_cast<std::chrono::nanoseconds>(e-s).count();
		_ret.set_db_latency(l);
	}

	void key_get(BenchmarkData& _ret, unique_ptr<string> key, unique_ptr<BenchmarkData> bd) {
		auto s = std::chrono::high_resolution_clock::now();
		copy_benchmark_data(_ret, bd);
		_ret.set_data(string(_ret.get_data_size(), 'A'));
		auto e = std::chrono::high_resolution_clock::now();
		auto l = std::chrono::duration_cast<std::chrono::nanoseconds>(e-s).count();
		_ret.set_db_latency(l);
	}
#endif
};

DEFINE_int32(server_port, 9090, "Server Port");

int main(int argc, char **argv) {
	folly::init(&argc, &argv, true);

	auto handler = make_shared<BenchmarkHandler>();
	auto server = make_shared<ThriftServer>();
	server->setInterface(handler);
	server->setPort(FLAGS_server_port);

	printf("Starting the server...\n");
	server->serve();
	printf("Done\n");

	return 0;
}

/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "gen-cpp2/LeafBenchmark.h"
#include <iostream>
#include <algorithm>
#include <vector>
#include <memory>
#include <stdexcept>
#include <sstream>
#include <chrono>
#include <folly/init/Init.h>
#include <folly/io/async/EventBase.h>
#include <folly/io/async/EventHandler.h>

#include <thrift/lib/cpp2/server/ThriftServer.h>
#include <thrift/lib/cpp/concurrency/ThreadManager.h>

#include "AsyncIO.h"

using namespace std;
using namespace apache::thrift;
using namespace apache::thrift::concurrency;
using namespace  ::example;
using namespace  ::example::cpp2;
using namespace folly;

using std::shared_ptr;
using std::unique_ptr;
using std::string;
using std::cout;
using std::endl;

class LeafHandler : virtual public LeafBenchmarkSvIf {
private:
	std::shared_ptr<ThreadManager> threadManager_{nullptr};
	AsyncIO asyncio_;
	bool    asyncio_inited_{false};
	string  path_;

private:
	size_t data_size;
	string data;
	void init_data(size_t size, string &ret_data) {
		if (data_size != size) {
			data = string(size, 'A');
			data_size = size;
		}
		ret_data = data;
	}

	string filename_to_path(string &filename) {
		return path_ + "/" + filename;
	}

public:
	LeafHandler(string &path) : asyncio_(128), path_(path) {
		// Your initialization goes here
		threadManager_ = ThreadManager::newSimpleThreadManager(12, 0, true, 0);
		assert(threadManager_);
		auto tf = std::make_shared<PosixThreadFactory>();
		threadManager_->threadFactory(tf);
		threadManager_->start();
	}

	~LeafHandler() {
		threadManager_->stop();
		threadManager_->join();
	}

	void async_tm_write(unique_ptr<HandlerCallback<void>> cb,
					unique_ptr<string> filename, unique_ptr<string> data) {

		if (asyncio_inited_ == false) {
			asyncio_.init(cb->getEventBase());
			asyncio_inited_ = true;
		}
		string fn = filename_to_path(*filename);
		//cout << "File Name " << fn << endl;
		int fd = open(fn.c_str(), O_WRONLY | O_TRUNC | O_DIRECT | O_CREAT, 0777);
		assert(fd >= 0);
		auto write = make_unique<IO>(fd, data->size(), 0, IOType::WRITE);
		char *bufp = write->getIOBuffer();
		data->copy(bufp, data->size());

		asyncio_.ioSubmit(std::move(write)).then([fd] (unique_ptr<IO> io) {
			close(fd);
		}).then([cb = std::move(cb)] () mutable {
			auto basep = cb->getEventBase();
			basep->runInEventBaseThread([cb = std::move(cb)] () mutable {
				cb->done();
			});
		});
	}

	void async_tm_read(unique_ptr<HandlerCallback<unique_ptr<LeafBenchmarkData>>> cb,
				unique_ptr<std::string> filename, int32_t size) {

		if (asyncio_inited_ == false) {
			asyncio_.init(cb->getEventBase());
			asyncio_inited_ = true;
		}

		auto ios   = std::chrono::high_resolution_clock::now();
		string fn  = filename_to_path(*filename);
		auto fd    = open(fn.c_str(), O_RDONLY | O_TRUNC | O_DIRECT);
		auto read  = make_unique<IO>(fd, size, 0, IOType::READ);

		auto f     = asyncio_.ioSubmit(std::move(read));
		f.then([this, cb = std::move(cb), fd, size, ios] (unique_ptr<IO> read) mutable {
			auto ioe = std::chrono::high_resolution_clock::now();
			auto iol = std::chrono::duration_cast<std::chrono::nanoseconds>(ioe-ios).count();
			close(fd);

			this->threadManager_->add([io = std::move(read), cb1 = std::move(cb), size, iol] () mutable {
				auto cs = std::chrono::high_resolution_clock::now();
				for (auto i = 0ull; i < 100; i++) {
				}
				auto ce = std::chrono::high_resolution_clock::now();
				auto cl = std::chrono::duration_cast<std::chrono::nanoseconds>(ce-cs).count();

				auto basep = cb1->getEventBase();
				basep->runInEventBaseThread([read = std::move(io), cb = std::move(cb1), size, iol, cl] () {
					LeafBenchmarkData _ret;
					_ret.set_io_latency(iol);
					_ret.data.assign(read->getIOBuffer(), size);
					_ret.set_cpu_consumed(cl);
					cb->result(_ret);
				});
			});
		});
	}
};

DEFINE_int32(server_port, 9091, "Server Port");
DEFINE_string(path, "/mnt/", "Location of files");

int main(int argc, char **argv) {
	folly::init(&argc, &argv, true);

	auto handler = make_shared<LeafHandler>(FLAGS_path);
	auto server  = make_shared<ThriftServer>();
	server->setInterface(handler);
	server->setPort(FLAGS_server_port);

	printf("Starting the server...\n");
	server->serve();
	printf("Done\n");

	return 0;
}

/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "gen-cpp2/LeafBenchmark.h"
#include <iostream>
#include <algorithm>
#include <vector>
#include <memory>
#include <stdexcept>
#include <sstream>
#include <chrono>
#include <folly/init/Init.h>
#include <folly/io/async/EventBase.h>
#include <folly/io/async/EventHandler.h>

#include <thrift/lib/cpp2/server/ThriftServer.h>
#include <thrift/lib/cpp/concurrency/ThreadManager.h>

using namespace std;
using namespace apache::thrift;
using namespace apache::thrift::concurrency;
using namespace  ::example;
using namespace  ::example::cpp2;
using namespace folly;

using std::shared_ptr;
using std::unique_ptr;
using std::string;
using std::cout;
using std::endl;

class LeafHandler : virtual public LeafBenchmarkSvIf {
private:
	std::shared_ptr<ThreadManager> threadManager_{nullptr};

private:
	size_t data_size;
	string data;
	void init_data(size_t size, string &ret_data) {
		if (data_size != size) {
			data = string(size, 'A');
			data_size = size;
		}
		ret_data = data;
	}

public:
	LeafHandler() {
		// Your initialization goes here
		threadManager_ = ThreadManager::newSimpleThreadManager(4, 0, true, 0);
		assert(threadManager_);
		auto tf = std::make_shared<PosixThreadFactory>();
		threadManager_->threadFactory(tf);
		threadManager_->start();
	}

	~LeafHandler() {
		threadManager_->stop();
		threadManager_->join();
	}

	void async_tm_key_put(unique_ptr<HandlerCallback<std::unique_ptr<LeafBenchmarkData>>> cb, 
			unique_ptr<string> key, unique_ptr<LeafBenchmarkData> ldb) {
		auto s     = std::chrono::high_resolution_clock::now();
		auto reqid = ldb->get_request_id();

		threadManager_->add([cb1 = std::move(cb), k = std::move(key), reqid, s] () mutable {
			/* burn some CPU */
			auto cs = std::chrono::high_resolution_clock::now();
			for (auto i = 0ull; i < 100ull; i++) {

			}
			auto ce  = std::chrono::high_resolution_clock::now();
			auto cpu = std::chrono::duration_cast<std::chrono::nanoseconds>(ce-cs).count();

			// cout << "Burned CPU.\n";

			auto basep = cb1->getEventBase();
			basep->runInEventBaseThread([cb = std::move(cb1), reqid, cpu, s] () mutable {
				auto e = std::chrono::high_resolution_clock::now();
				auto l = std::chrono::duration_cast<std::chrono::nanoseconds>(e-s).count();

				// cout << "Sending Result.\n";
				LeafBenchmarkData _ret;
				_ret.set_request_id(reqid);
				_ret.data.clear();
				_ret.set_data_size(0);
				_ret.set_leaf_latency(l);
				_ret.set_io_latency(0);
				_ret.set_cpu_consumed(cpu);

				cb->result(_ret);
			});
		});
	}

#if 0
	void async_tm_key_get(unique_ptr<HandlerCallback<unique_ptr<BenchmarkData>>> callback, unique_ptr<string> key, unique_ptr<BenchmarkData> bench) {
		auto s = std::chrono::high_resolution_clock::now();

		BenchmarkData _ret;
		copy_benchmark_data(_ret, bench);

		init_data(_ret.data_size, _ret.data);

		auto e = std::chrono::high_resolution_clock::now();
		auto l = std::chrono::duration_cast<std::chrono::nanoseconds>(e-s).count();
		_ret.set_db_latency(l);
		callback->result(_ret);
	}
#endif
};

DEFINE_int32(server_port, 9091, "Server Port");

int main(int argc, char **argv) {
	folly::init(&argc, &argv, true);

	auto handler = make_shared<LeafHandler>();
	auto server = make_shared<ThriftServer>();
	server->setInterface(handler);
	server->setPort(FLAGS_server_port);

	printf("Starting the server...\n");
	server->serve();
	printf("Done\n");

	return 0;
}
